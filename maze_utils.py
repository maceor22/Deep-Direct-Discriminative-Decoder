from copy import deepcopy
import scipy.io as sio
from utils import *
import matplotlib.pyplot as plt
import torch
import numpy as np


# plot maze data for a given rat and session
def plot_maze(name, session, Fs, n_points):
    # name: name of rat
    # session: session to be plotted
    # Fs: sampling frequency
    # n_points: number of points to be included
    
    # load spike and position data specific to rat name and session
    if name == 'Remy':        
        spikesFile = sio.loadmat(f'Datasets/SunMaze/Remy/remymarks{session[0]}.mat')['marks'][0][-1][0][session[1]][0]
        rem = [0,4,7,15,17,26]
        
        posRaw = sio.loadmat(f'Datasets/SunMaze/Remy/remypos{session[0]}.mat')['pos'][0][-1][0][session[1]][0][0][3][:,1:5]
        
    elif name == 'Jaq':
        spikesFile = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqspikes0{session[0]}.mat')['spikes'][0][-1][0][session[1]][0]
        rem = [12,18]
        
        if session[0] <= 2:
            posRaw = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqpos0{session[0]}.mat')['pos'][0][-1][0][session[1]][0][0][0][:,1:5]
        else:
            posRaw = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqposdlc0{session[0]}.mat')['posdlc'][0][-1][0][session[1]][0][0][0][:,1:3]
            posRaw = np.delete(posRaw, np.where(np.isnan(posRaw)), axis = 0)
        
    elif name == 'Bon':
        with h5py.File(f'Datasets/SunMaze/Bon/bonpos0{session[0]}.mat', 'r') as f:
            posRaw = open(f['pos'])
    
    
    posRaw -= posRaw.min(axis = 0)
    if n_points != 'all':
        posRaw = posRaw[:n_points,:]    
    
    # plotting
    plt.figure()
    plt.plot(posRaw[:,0], posRaw[:,1], '0.4')
    
    plt.xlabel('X axis')
    plt.ylabel('Y axis')
    plt.title('Maze Shape (X-Y) view')
    
    
    dt = 0.033
    Time = np.arange(posRaw.shape[0]) * dt
    
    fig, ax = plt.subplots(2, 1, sharex = True)
    
    plt.xlabel('Time [s]')
    
    ax[0].plot(Time, posRaw[:,0], 'k')
    ax[0].set_ylabel('X position')
    
    ax[1].plot(Time, posRaw[:,1], 'k')
    ax[1].set_ylabel('Y position')
    
    fig.suptitle('Trajectory versus Time')


# method for plotting predictions generated by trajectory model
def plot_model_predictions(pred_mean, pred_vars, label_data, title, plot_arm_probs = False, arm_probs = None):    
    # pred_mean: prediction mean
    # pred_vars: prediction variance
    # label_data: data used for labels
    # title: title of plot
    # plot_arm_probs: boolean indicating whether to plot arm probability values; only used if arm model is used
    # arm_probs: arm probability values; only used if arm model is used
    
    # specifying number of sublots in figure
    if plot_arm_probs and arm_probs is not None:
        n_subplots = 3
        arm_probs = arm_probs.detach().numpy().transpose()
    else:
        n_subplots = 2
    
    # convert to numpy
    pred_mean = pred_mean.detach().numpy()
    pred_sdev = pred_vars.detach().numpy()**0.5
    label_data = label_data.detach().numpy()
    
    # time axis
    dt = 0.033
    Time = np.arange(label_data.shape[0]) * dt
    
    # plotting
    fig, ax = plt.subplots(2, 1, sharex = True)
    
    plt.xlabel('Time [s]')
    
    ax[0].plot(Time, label_data[:,0], 'k', label = 'actual')
    ax[0].plot(Time, pred_mean[:,0], 'red', label = 'pred mean', linewidth = 0.7)
    ax[0].fill_between(
        Time,
        pred_mean[:,0] + pred_sdev[:,0],
        pred_mean[:,0] - pred_sdev[:,0],
        color = 'lightsalmon',
        label = 'pred sdev',
        )
    ax[0].legend(fontsize = 6, loc = 2)
    ax[0].set_ylabel('X position')
    
    ax[1].plot(Time, label_data[:,1], 'k', label = 'actual')
    ax[1].plot(Time, pred_mean[:,1], 'red', label = 'pred mean', linewidth = 0.7)
    ax[1].fill_between(
        Time,
        pred_mean[:,1] + pred_sdev[:,1],
        pred_mean[:,1] - pred_sdev[:,1],
        color = 'lightsalmon',
        label = 'pred sdev',
        )
    ax[1].legend(fontsize = 6, loc = 2)
    ax[1].set_ylabel('Y position')
    
    fig.suptitle(title)
    plt.show()
    
    if plot_arm_probs and arm_probs is not None:
        fig, ax = plt.subplots(1,1)
        img = ax.imshow(arm_probs, extent = [0, Time[-1], 0, min(arm_probs.shape)])
        plt.xlabel('Time [s]')
        ax.set_ylabel('Arms')
        plt.show()
# =============================================================================
#         fig.subplots_adjust(left = 0.07, right = 0.87)
#         img = ax[2].imshow(arm_probs, extent = [0, Time[-1], 0, min(arm_probs.shape)])
#         box = ax[2].get_position()
#         pad, width = 0.02, 0.02
#         cax = fig.add_axes([box.xmax + pad, box.ymin, width, box.height])
#         fig.colorbar(img, cax = cax)
#         fig.subplots_adjust(wspace = 0, hspace = 0)
# =============================================================================
    
    
# class used to loading and holding maze data (spike data and position data)
class Maze(object):
    
    def __init__(self, name, session, n_points, Fs, rem_insig_chans = False, threshold = None):
        # name: name of rat
        # session: session to be plotted
        # Fs: sampling frequency
        # rem_insig_chans: boolean indicating whether to remove insignificant channels
        # threshold: spike frequency threshold to determine significance of spike channel
        
        self.info = {
            'name' : name,
            'session' : session,
            'n_points' : n_points,
            'Fs' : Fs,
            }
        
        # load spike and position data for given rat name and session
        if name == 'Remy':        
            spikesFile = sio.loadmat(f'Datasets/SunMaze/Remy/remymarks{session[0]}.mat')['marks'][0][-1][0][session[1]][0]
            rem = [0,4,7,15,17,26]
            
            posRaw = sio.loadmat(f'Datasets/SunMaze/Remy/remypos{session[0]}.mat')['pos'][0][-1][0][session[1]][0][0][3][:,:5]
            
        
        elif name == 'Jaq':
            spikesFile = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqspikes0{session[0]}.mat')['spikes'][0][-1][0][session[1]][0]
            rem = [12,18]
            
            if session[0] <= 2:
                posRaw = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqpos0{session[0]}.mat')['pos'][0][-1][0][session[1]][0][0][0][:,1:5]
            else:
                posRaw = sio.loadmat(f'Datasets/SunMaze/Jaq/Jaqposdlc0{session[0]}.mat')['posdlc'][0][-1][0][session[1]][0][0][0]
        
            
        # remove certain ntrodes due to nan values or missing data    
        ntrodes = [i for i in range(30) if i not in rem]
        
        # basic data cleaning to yield spike train data from spike times
        dat = []
        for n in ntrodes:
            dat.append(spikesFile[n][0][0][-2])

        min_ = 1e99999
        max_ = -1e99999
        for d in dat:
            m = d.min(axis=0)[0]
            if m < min_:
                min_ = m
            
            m = d.max(axis=0)[0]
            if m > max_:
                max_ = m
        
        if n_points == 'all':
            t_end = 1e99
        else:
            t_end = n_points / Fs
        
        self.info['time_length_sec'] = t_end
        
        data = []
        for d in dat:
            d -= min_
            
            idx = 0
            while d[idx] < t_end:
                idx += 1
            
            data.append(d[:idx])
        
        neurons = []
        for d in data:
            idxs = torch.from_numpy(d * Fs).round()     

            neuron = torch.zeros((1,n_points))
            neuron[0,idxs.long()] = 1
            
            neurons.append(neuron)
        
        self.spikes = torch.cat(neurons, dim = 0)

        if rem_insig_chans:
            if threshold == None:
                threshold = 100
            
            self.spikes = torch.cat([
                self.spikes[i,:].unsqueeze(0) for i in range(self.spikes.size(0))
                if self.spikes[i,:].sum() >= threshold
                ], dim = 0)                
        
        
        # preprocessing to yield xvel and yvel from vel and dir
        posRaw[:,:3] -= posRaw[:,:3].min(axis = 0)
        
        xvel = posRaw[:,4] * np.cos(posRaw[:,3])
        yvel = posRaw[:,4] * np.sin(posRaw[:,3])
            
        posRaw[:,3] = xvel
        posRaw[:,4] = yvel
        
        # other position data preprocessing
        if n_points == 'all':
            posRaw = torch.from_numpy(posRaw)
        else:
            idx = 0
            while posRaw[idx,0] < t_end:
                idx += 1
            posRaw = torch.from_numpy(posRaw[0:idx,:])
        self.posRaw = posRaw[:,1:]
        
        idxs = torch.cat([
            (posRaw[:,0] * Fs).floor(),
            torch.tensor([n_points]),
            ]).long()
        
        posx = []
        posy = []
        for i in range(posRaw.size(0)):
            len_ = idxs[i+1] - idxs[i]
            posx.append(posRaw[i,1].repeat(len_))
            posy.append(posRaw[i,2].repeat(len_))
        
        self.x_pos = torch.cat(posx, dim = 0)
        self.y_pos = torch.cat(posy, dim = 0)    
        
    
    # method for downsampling position data
    def downsample_position(self, bin_size = 10, overlap = 0):
        # bin_size: size of bin to use when downsampling
        # overlap: overlap between sequential bins during downsampling
        
        lower = 0
        upper = bin_size
        step = bin_size - overlap
        
        data_avg = []
        data_var = []
        
        # loop for downsampling
        while upper <= self.posRaw.size(dim = 0):
            # save mean and variance of data in downsampled bin
            data_avg.append(self.posRaw[lower:upper,:].mean(dim = 0).unsqueeze(dim = 0))
            data_var.append(self.posRaw[lower:upper,:].var(dim = 0, unbiased = True).unsqueeze(dim = 0))
        
            lower += step
            upper += step
        
        # concatenate bin means and bin vars
        new_data = torch.cat([
            torch.cat(data_avg, dim = 0),
            torch.cat(data_var, dim = 0),
            ], dim = 1).unsqueeze(-1)
        
        return new_data
        
    
    # method for generating position history given raw data
    def generate_position_history(self, history_length = 0):
        posRaw = self.posRaw.unsqueeze(-1)
        
        history_data = []
        # loop for aggregating position history
        for i in range(history_length, posRaw.size(dim = 0)):
            # get current timestep and history, then reshape and save to list
            new = posRaw[i-history_length:i,:,:].transpose(0,-1).transpose(1,-1)
            history_data.append(new)
        
        # concatenate position history data and return
        return torch.cat(history_data, dim = 0).float()
                
    
    # method for plotting heat map of spike train data
    def plot_spikes_heat_map(self, directory = None):
        spikes = self.spikes.numpy()
                
        Fs = self.info['Fs']
        ntrode = np.arange(0, spikes.shape[0], 1)
        tstep  = np.arange(0, spikes.shape[1], 1) / Fs
        
        fig, ax = plt.subplots()
        ax.pcolormesh(tstep, ntrode, spikes)
        plt.xlabel('Time [s]')
        plt.ylabel('Ntrode #')
        plt.title(f'Spikes over time | Time resolution: {Fs} Hz')
        plt.show()
        
    
    # method for plotting position data
    def plot_position(self, plot_map = False, plot_over_time = False, directory = None):
        x_pos, y_pos = self.x_pos.numpy(), self.y_pos.numpy()
        n_points = x_pos.shape[0]
        Fs = self.info['Fs']
        
        # plot x-y view map
        if plot_map:
            plt.figure()
            idx = [0, n_points*.1, n_points*.2, n_points*.3, n_points*.4, n_points*.5, 
                   n_points*.6, n_points*.7, n_points*.8, n_points*.9, n_points-1]
            
            plt.plot(x_pos, y_pos, '0.4')
            for i in idx:
                plt.text(
                    x_pos[int(i)], y_pos[int(i)], 
                    't=%.3fs' % (int(i)/Fs),
                    fontsize = 8, color = 'blue'
                    )
            plt.xlabel('X axis')
            plt.ylabel('Y axis')
            plt.title('Rat Position (X-Y view)')
            plt.show()
        
        # plot x and y independently versus time
        if plot_over_time:
            fig, ax = plt.subplots(2, 1, sharex = True)
            Time = np.arange(0,n_points)/Fs
            
            ax[0].plot(Time, x_pos, 'blue')
            ax[1].plot(Time, y_pos, 'orange')
        
            ax[0].set_ylabel('X Position')
            ax[1].set_ylabel('Y Position')
            
            plt.xlabel('Time [s]')
            fig.suptitle('Rat Position vs Time')
            
            
# class for applying range normalize transform to position data
class RangeNormalize(object):
    
    def __init__(self, velocity_data = False):
        self.velocity_data = velocity_data
        
    # method for fitting transform object
    def fit(self, data = None, pos_mins = None, pos_maxs = None):
        if data is not None:
            if self.velocity_data:
                self.pos_mins, _ = data[:,-1,:2].min(dim = 0)
                self.pos_maxs, _ = data[:,-1,:2].max(dim = 0)
        
                self.vel_mean = data[:,-1,2:].mean(dim = 0)
                self.vel_std  = data[:,-1,2:].std(dim = 0)
            else:
                self.pos_mins, _ = data[:,-1,:].min(dim = 0)
                self.pos_maxs, _ = data[:,-1,:].max(dim = 0)
        else:
            self.pos_mins = pos_mins
            self.pos_maxs = pos_maxs
            
    # method for applying transform to position data
    def transform(self, data):
        new_data = deepcopy(data.detach())
        if self.velocity_data:
            new_data[:,:,:2] = (data[:,:,:2] - self.pos_mins) / (self.pos_maxs - self.pos_mins)
            new_data[:,:,2:] = (data[:,:,2:] - self.vel_mean) / self.vel_std
        else:
            new_data = (data - self.pos_mins) / (self.pos_maxs - self.pos_mins)
        return new_data
    
    # method that runs fit and transform on position data
    def fit_transform(self, data):
        self.fit(data)
        return self.transform(data)
    
    # method for untransforming transformed data
    def untransform(self, data, variance = None):
        new_data = deepcopy(data.detach())
        if self.velocity_data:
            new_data[:,:,:2] = data[:,:,:2] * (self.pos_maxs - self.pos_mins) + self.pos_mins
            new_data[:,:,2:] = data[:,:,2:] * self.vel_std + self.vel_mean
        else:
            new_data = data * (self.pos_maxs - self.pos_mins) + self.pos_mins
            
        if variance == None:
            return new_data
        else:
            new_var = variance * (self.pos_maxs - self.pos_mins)
            return new_data, new_var
        
        
# class for applying one type of arm-dist transform to position data
class WMazeDiscreteTransform1(object):
    
    # optionally range normalize position data before fitting and transforming
    def __init__(self, range_norm = False):
        self.range_norm = range_norm
        
    # method for fitting transform object
    def fit(self, data):        
        self.center = torch.zeros((4,))
        c = [[],[],[],[]]
        
        for i in range(data.size(0)):
            if data[i,-1,1] > 80:
                c[0].append(data[i,-1,1].item())
            else:
                if data[i,-1,0] < 30:
                    c[1].append(data[i,-1,0].item())
                elif data[i,-1,0] < 70:
                    c[2].append(data[i,-1,0].item())
                else:
                    c[3].append(data[i,-1,0].item())
        
        if self.range_norm:
            self.range = torch.zeros((4,2))
            for i in range(4):
                #c = torch.Tensor(c[i])
                self.center[i] = torch.tensor(c[i]).mean()
                mi = min(c[i])
                ma = max(c[i])
                self.range[i,0] = ma - mi
            self.range[0,1] = 100
            self.range[1:,1] = 80
        
        else:
            for i in range(4):
                self.center[i] = torch.tensor(c[i]).mean()
            
    # method for applying transform to position data
    def transform(self, data):
        new_data = torch.zeros((data.size(0), data.size(1),6))
        
        for i in range(data.size(0)):
            for j in range(data.size(1)):
                
                if data[i,j,1] > 80:
                    new_data[i,j,0] = 1
                    new_data[i,j,4] = self.center[0] - data[i,j,1]
                    new_data[i,j,5] = data[i,j,0]
                    
                    if self.range_norm:
                        new_data[i,j,4] /= self.range[0,0]
                        new_data[i,j,5] /= self.range[0,1]
                    
                else:
                    if data[i,j,0] < 30:
                        new_data[i,j,1] = 1
                        new_data[i,j,4] = self.center[1] - data[i,j,0]
                        new_data[i,j,5] = 80 - data[i,j,1]
                        
                        if self.range_norm:
                            new_data[i,j,4] /= self.range[1,0]
                            new_data[i,j,5] /= self.range[1,1]
                    
                    elif data[i,j,0] < 70:
                        new_data[i,j,2] = 1
                        new_data[i,j,4] = self.center[2] - data[i,j,0]
                        new_data[i,j,5] = 80 - data[i,j,1]
                        
                        if self.range_norm:
                            new_data[i,j,4] /= self.range[2,0]
                            new_data[i,j,5] /= self.range[2,1]
                    
                    else:
                        new_data[i,j,3] = 1
                        new_data[i,j,4] = self.center[3] - data[i,j,0]
                        new_data[i,j,5] = 80 - data[i,j,1]
                        
                        if self.range_norm:
                            new_data[i,j,4] /= self.range[3,0]
                            new_data[i,j,5] /= self.range[3,1]
        
        return new_data
                
    # method that runs fit and transform on position data
    def fit_transform(self, data):
        self.fit(data)
        return self.transform(data)
    
    # method for untransforming transformed position data
    def untransform(self, data, variance = None):
        new_data = torch.zeros((data.size(0), data.size(1), 2))
        
        for i in range(data.size(0)):
            for j in range(data.size(1)):
                
                if data[i,j,0] == 1:
                    if self.range_norm:
                        new_data[i,j,0] = data[i,j,5] * self.range[0,1]
                        new_data[i,j,1] = self.center[0] - (self.range[0,0] * data[i,j,4])
                    else:
                        new_data[i,j,0] = data[i,j,5]
                        new_data[i,j,1] = self.center[0] - data[i,j,4]
                
                elif data[i,j,1] == 1:
                    if self.range_norm:
                        new_data[i,j,0] = self.center[1] - (self.range[1,0] * data[i,j,4])
                        new_data[i,j,1] = 80 - (data[i,j,5] * self.range[1,1])
                    else:
                        new_data[i,j,0] = self.center[1] - data[i,j,4]
                        new_data[i,j,1] = 80 - data[i,j,5]
                    
                elif data[i,j,2] == 1:
                    if self.range_norm:
                        new_data[i,j,0] = self.center[2] - (self.range[2,0] * data[i,j,4])
                        new_data[i,j,1] = 80 - (data[i,j,5] * self.range[2,1])
                    else:
                        new_data[i,j,0] = self.center[2] - data[i,j,4]
                        new_data[i,j,1] = 80 - data[i,j,5]
        
                else:
                    if self.range_norm:
                        new_data[i,j,0] = self.center[3] - (self.range[3,0] * data[i,j,4])
                        new_data[i,j,1] = 80 - (data[i,j,5] * self.range[3,1])
                    else:
                        new_data[i,j,0] = self.center[3] - data[i,j,4]
                        new_data[i,j,1] = 80 - data[i,j,5]
                    
                    
        if variance == None:
            return new_data
        else:
            new_var = torch.zeros((variance.size(0), 2))
            for i in range(variance.size(0)):
                
                if data[i,-1,0] == 1:
                    if self.range_norm:
                        new_var[i,0] = variance[i,1] * self.range[0,1]
                        new_var[i,1] = variance[i,0] * self.range[0,0]
                    else:
                        new_var[i,0] = variance[i,1]
                        new_var[i,1] = variance[i,0]
                
                elif data[i,-1,1] == 1 and self.range_norm:
                    new_var[i,0] = variance[i,0] * self.range[1,0]
                    new_var[i,1] = variance[i,1] * self.range[1,1]
            
                elif data[i,-1,2] == 1 and self.range_norm:
                    new_var[i,0] = variance[i,0] * self.range[2,0]
                    new_var[i,1] = variance[i,1] * self.range[2,1]
                    
                elif data[i,-1,3] == 1 and self.range_norm:
                    new_var[i,0] = variance[i,0] * self.range[3,0]
                    new_var[i,1] = variance[i,1] * self.range[3,1]
                    
                else:
                    new_var[i,0] = variance[i,0]
                    new_var[i,1] = variance[i,1]
            
            return new_data, new_var
    
    
# class for applying a second type of arm-dist transform to position data
class WMazeDiscreteTransform2(object):
    
    # optionally range normalize position data before fitting and applying transform
    def __init__(self, range_norm = False):
        self.range_norm = range_norm
        
    # method for fitting transform object
    def fit(self, data):        
        self.center = torch.zeros((4,))
        c = [[],[],[],[]]
        
        for i in range(data.size(0)):
            if data[i,-1,1] > 80:
                c[0].append(data[i,-1,1].item())
            else:
                if data[i,-1,0] < 30:
                    c[1].append(data[i,-1,0].item())
                elif data[i,-1,0] < 70:
                    c[2].append(data[i,-1,0].item())
                else:
                    c[3].append(data[i,-1,0].item())
        
        if self.range_norm:
            self.range = 100
        
        for i in range(4):
            self.center[i] = torch.tensor(c[i]).mean()
            
    # method for transforming position data
    def transform(self, data):
        m = torch.zeros((4,))
        m[0] = -1
        m[1] = 1
        m[2] = -1
        m[3] = 1
        
        b = torch.zeros((4,))
        b[0] = self.center[0] - m[0] * self.center[1]
        b[1] = self.center[0] - m[1] * self.center[2]
        b[2] = self.center[0] - m[2] * self.center[2]
        b[3] = self.center[0] - m[3] * self.center[3]
        
        new_data = torch.zeros((data.size(0), data.size(1),6))
        
        for i in range(data.size(0)):
            for j in range(data.size(1)):
                
                boolean0 = data[i,j,1]<=m[0]*data[i,j,0]+b[0]
                boolean1 = (data[i,j,1]<=m[1]*data[i,j,0]+b[1]) and (data[i,j,1]<=m[2]*data[i,j,0]+b[2])
                boolean2 = data[i,j,1]<=m[3]*data[i,j,0]+b[3]
                
                if data[i,j,0] < 30 and boolean0:
                    new_data[i,j,2] = 1
                    new_data[i,j,5] = (self.center[0] - data[i,j,1]) + (self.center[2] - self.center[1])
                
                elif data[i,j,0] < 70 and boolean1:
                    new_data[i,j,3] = 1
                    new_data[i,j,5] = self.center[0] - data[i,j,1]
                
                elif data[i,j,0] >= 70 and boolean2:
                    new_data[i,j,4] = 1
                    new_data[i,j,5] = (self.center[0] - data[i,j,1]) + (self.center[3] - self.center[2])
                        
                elif data[i,j,0] < self.center[2]:
                    new_data[i,j,0] = 1
                    new_data[i,j,5] = self.center[2] - data[i,j,0]
                
                else:
                    new_data[i,j,1] = 1
                    new_data[i,j,5] = data[i,j,0] - self.center[2]
        
        if self.range_norm:
            new_data[:,:,5] /= self.range
        
        return new_data
                
    # method that runs fit and transform on position data
    def fit_transform(self, data):
        self.fit(data)
        return self.transform(data)
    
    # method for untransforming transformed position data
    def untransform(self, data, variance = None):
        new_data = torch.zeros((data.size(0), data.size(1), 2))
        
        for i in range(data.size(0)):
            for j in range(data.size(1)):
                
                if data[i,j,0] == 1:
                    if self.range_norm:
                        new_data[i,j,0] = self.center[2] - (self.range * data[i,j,5])
                    else:
                        new_data[i,j,0] = self.center[2] - data[i,j,5]                    
                    new_data[i,j,1] = self.center[0]
                
                elif data[i,j,1] == 1:
                    if self.range_norm:
                        new_data[i,j,0] = self.center[2] + (self.range * data[i,j,5])
                    else:
                        new_data[i,j,0] = self.center[2] + data[i,j,5]
                    new_data[i,j,1] = self.center[0]
                    
                elif data[i,j,2] == 1:
                    new_data[i,j,0] = self.center[1]
                    if self.range_norm:
                        new_data[i,j,1] = self.center[0] - (self.range * data[i,j,5] - (self.center[2] - self.center[1]))
                    else:
                        new_data[i,j,1] = self.center[0] - (data[i,j,5] - (self.center[2] - self.center[1]))
        
                elif data[i,j,3] == 1:
                    new_data[i,j,0] = self.center[2]
                    if self.range_norm:
                        new_data[i,j,1] = self.center[0] - (self.range * data[i,j,5])
                    else:
                        new_data[i,j,1] = self.center[0] - data[i,j,5]
                        
                elif data[i,j,4] == 1:
                    new_data[i,j,0] = self.center[3]
                    if self.range_norm:
                        new_data[i,j,1] = self.center[0] - (self.range * data[i,j,5] - (self.center[3] - self.center[2]))
                    else:
                        new_data[i,j,1] = self.center[0] - (data[i,j,5] - (self.center[3] - self.center[2]))
                    
                    
        if variance == None:
            return new_data
        else:
            new_var = torch.zeros((variance.size(0), 2))
            for i in range(variance.size(0)):
                
                if data[i,-1,0] == 1 or data[i,-1,1] == 1:
                    new_var[i,0] = variance[i]
                    
                else:
                    new_var[i,1] = variance[i]
                
            if self.range_norm:
                new_var *= self.range
            
            return new_data, new_var
    
    
    
    
    
